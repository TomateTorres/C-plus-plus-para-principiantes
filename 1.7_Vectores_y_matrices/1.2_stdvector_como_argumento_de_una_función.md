En la sección sobre [funciones](../1.3_Funciones_basicas/), ya habíamos hablado sobre el [paso por valor](../1.3_Funciones_basicas/2.0_Intro_a_parámetros_de_funciones_y_argumentos.md) y el [paso por referencia](../1.3_Funciones_basicas/2.5_Paso_por_referencia.md) de argumentos.

A estos conceptos agregaremos uno nuevo antes de meternos de lleno a cómo pasar vectores como argumentos de funciones: el **paso por referencia constante `const &`**.

En el contexto de funciones en C++, pasar un argumento por referencia constante significa que le pasamos a la función una referencia al objeto original (evitando la creación de una copia), pero a la vez garantizamos que la función no podrá modificar ese objeto dentro de su cuerpo. Esta técnica es muy útil cuando queremos que una función tenga acceso de solo lectura a un objeto grande o complejo sin necesidad de copiarlo, pero también asegurárnos de que el objeto no será alterado.

Recordemos que, cuando **pasamos un argumento por referencia** en una función, usamos `&` después del tipo del argumento. Esto le dice al compilador que la función no debe recibir una copia del argumento, sino una referencia directa al objeto original. Así, la función opera sobre el mismo objeto que fue pasado desde el exterior:

```
#include <vector>
#include <iostream>

void funcionPorReferencia(int& x) {
    x = 10;  // Modifica el valor de la variable original
}

int main() {
    int a{5}; // `a` es definida e inicializada como un entero 
              // de valor 5.
    
    funcionPorReferencia(a); // `a` es modificada por la 
                             // `funcionPorReferencia`
    // `a` ahora es 10

    return 0;
}
```
En este ejemplo, `x` es una referencia a `a`, por lo que cualquier cambio que hagamos en `x` dentro de la función también afectará a `a`.

La palabra constante `const` en C++ se usa para indicar que un valor no puede ser modificado. Cuando aplicamos `const` a una referencia en el contexto de una función, estamos diciendo que la referencia no puede usarse para modificar el objeto al que apunta.

```
#include <vector>
#include <iostream>

void funcionPorReferenciaConstante(const int& x) {
  //x = 10;  // Error, `x` es constante, no se puede modificar

  std::cout << x; // Pero se puede leer el valor o realizar 
                  // cualquier acción que no lo modifique.

}

int main() {
  int a{5}; // `a` es definida e inicializada como un entero 
            // de valor 5.
    
  funcionPorReferenciaConstante(a); 
  // `a` es pasada como referencia constante, se le puede 
  // realizar cualquier acción que no lo modifique.

  return 0;
}
```

Cuando hablamos de **paso por referencia constante `const &`**, estamos combinando dos ideas:
* El argumento es pasado **por referencia**, por lo que no se crea una copia del mismo.
* Esa referencia está marcada como **constante**, lo que impide que la función modifique el objeto referenciado.

Esta es una práctica muy común y recomendada cuando el argumento de una función es un objeto grande (como puede ser un array de muchos elementos) que no necesita ser modificado dentro de la función y donde no queremos hacer una copia completa por razones de eficiencia.

## Pasar un `std::vector` como argumento de una función.

Un `std::vector` puede ser pasado como el argumento de una función al igual que cualquier otro tipo de objeto. 
```
void miFuncion(std::vector<int> vector);
// `miFuncion` recibe vectores (paso por valor) de tipo `<int>`,
// siempre que querramos usar un `std::vector` como argumento
// de una función, debemos especiicar el tipo de los elementos
// de éste (no podemos omitir `<tipo>`).
```

Podemos pasarlo **por valor:**
```
#include <vector>
#include <iostream>
#include <string>

void TeHeFalladoAnakin(std::vector<std::string> v)
{ // La función `TeHeFalladoAnakin` pasa el argumento que le 
  // demos por valor. Se crea una copia local de `v`

    v[2] = "Vader"; // Se modifica el elemento con índice 2 del
                    // vector `v`.

} // La copia local del vector `v` es destruida.

int main()
{
	std::vector<std::string> dosJedisYmedio{ "Ahsoka", "Obi-Wan", 
                                             "Anakin" }; 

    TeHeFalladoAnakin(dosJedisYmedio);
    // Pasamos una copia de `dosJedisYMedio`, los cambios que 
    // hace la función, sólo se aplican a esa copia local.

    std::cout << dosJedisYmedio[2]; 
    // Se imprime el elemento con índice 2 de `dosJedisYMedio`
    // que definimos dentro de `main`. O sea, Anakin no se
    // convirtió en Vader.
                                                                          
	return 0;
}
```

Por **referencia:**
```
#include <vector>
#include <iostream>
#include <string>

void TeHeFalladoAnakin(std::vector<std::string>& v)
{ // La función `TeHeFalladoAnakin` pasa el argumento que le 
  // demos por referencia. Estamos trabajando directamente con
  // el vector `v`.

    v[2] = "Vader"; // Se modifica el elemento con índice 2 del
                    // vector `v`.

}

int main()
{
	std::vector<std::string> dosJedisYmedio{ "Ahsoka", "Obi-Wan", 
                                             "Anakin" }; 

    TeHeFalladoAnakin(dosJedisYmedio);
    // Pasamos `dosJedisYMedio`, los cambios que hace la 
    // función, se aplican directamente a `dosJedisYMedio`.

    std::cout << dosJedisYmedio[2]; 
    // Se imprime el elemento con índice 2 de `dosJedisYMedio`
    // después de ser modificado por `TeHeFalladoAnakin`. O sea,
    // Anakin se convirtió en lo que juró destruir.
                                                                          
	return 0;
}
```

O por **referencia constante:**
```
#include <vector>
#include <iostream>
#include <string>

void TeHeFalladoAnakin(const std::vector<std::string>& v)
{ // La función `TeHeFalladoAnakin` pasa el argumento que le 
  // demos por referencia constante. Estamos trabajando 
  // directamente con el vector `v` y podemos realizar 
  // cualquier acción que no lo modifique.
    
  if("Anakin"==v[2]){ // Verificamos que el string "Anakin"
                      // tenga el índice 2 en el vector `v`.
                      // Esta acción no modifica al vector.
    std::cout << "¡Tú eras el Elegido!";
  }

}

int main()
{
	std::vector<std::string> dosJedisYmedio{ "Ahsoka", "Obi-Wan", 
                                             "Anakin" }; 

  TeHeFalladoAnakin(dosJedisYmedio);
  // Pasamos `dosJedisYMedio` como argumento.
                                                                          
	return 0;
}
```

En resumen:
| Forma de pasar el vector                          | ¿Crea copia? | ¿Se puede modificar?       | Eficiencia  |
| ------------------------------------------------- | ------------ | -------------------------- | ----------- |
| Por valor (`std::vector v`)                       |        Sí    | Sí (pero la copia local)   | Baja        |
| Por referencia (`std::vector& v`)                 |        No    | Sí (el original)           | Alta        |
| Por referencia constante (`const std::vector& v`) |         No   |  No                        | Alta        |

