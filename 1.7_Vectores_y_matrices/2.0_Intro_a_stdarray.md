Los `std::array`*s* son arrays diseñados para funcionar de manera similar a `std::vector`. En general, hay más similaridades que diferencias entre ellos.

`std::vector` tiene un rendimiento ligeramente menor que `std::array` (o cualquier tipo de array de tamaño fijo). En la mayoría de los casos esta diferencia no será notoria (a menos que estemos escribiendo código descuidado), pero cuando se trata de programas más grandes donde estemos trabajando con muchos arrays, estas pequeñas diferencias iniciales pueden traducirse en tiempos de ejecución notoriamente más cortos. Además de que, como los `std::array` son arrays de tamaño fijo, existen herramientas dentro del propio compilador para poder detectar cuando nos estemos saliendo de sus límites desde antes de ejecutar el programa (cosa que no ocurría [con los índices en los `std::vector`](1.0_Intro_a_stdvector.md)).

Para declarar un `std::array` hacemos algo así:
```c++
#include <array> // Para poder usar `std::array`
#include <vector> // Para poder usar `std::vector`

int main()
{
  std::array<int, 5> elArray{}; // `elArray` es un `std::array` de 5 enteros.

  std::vector<int> elVector(5); // `elVector` es un `std::vector` de 5 enteros (para
                                // comparar).
                                
  return 0;
}
```

Para declarar un `std::array` dentro de `<>` tenemos dos argumentos: El primero (en el ejemplo, `int`) nos indica el tipo de elementos que tendrá nuestro array, el segundo (en el ejemplo, `5`) nos dice cuántos elementos tendrá.

Como ya hemos mencionado antes, los `std::array` son arrays de **tamaño fijo**, esto quiere decir que (a diferencia de los `std::vector`) su longitud debe ser una **expresión constante en tiempo de compilación**.

En términos simples, una **expresión constante en tiempo de compilación** en C++ es algo que tiene un valor fijo que **no cambia durante la ejecución del programa** y es conocido desde antes de que se corra el programa. Esto significa que el valor es conocido y asignado en el momento de la compilación, y **no se puede modificar después**.

Declarar algo como `const` en C++ es una forma de asegurar que ese valor permanece fijo y, por lo tanto, ayuda a prevenir errores donde accidentalmente intentemos cambiar algo que debe ser constante y permite que lo que sea que declaramos pueda ser usado en contextos donde se necesite una expresión constante.
```c++
const int longitud { 5 }; // Es una expresión constante. `longitud` siempre tendrá el 
                          // valor de 5 y no podrá modificarse en ninguna parte del 
                          // programa.

longitud = 6; // Esto no se puede hacer.
```
```c++
int longitud { 5 }; // `longitud` es una variable normal, no constante
                      // El valor de 5 puede modificarse. 

longitud = 6; // Esto sí se puede hacer.
```

De este modo, es perfectamente válido declarar `std::array`*s* de las formas:
```c++
#include <array>
int main()
{
  std::array<int, 7> elArray1{}; // Es una manera válida de declarar un `std::array` porque
                                 // `7` es una literal, que es una expresión constante.
  
  const int longitud{8}; // `longitud` es una expresión constante.
  std::array<int, longitud> elArray2{}; // Es una manera válida de declarar un `std::array` 
                                        // porque `longitud` fue declarada con `const`.

  return 0;
}
```

Pero no podemos hacerlo así:
```c++
#include <array>
#include <iostream>

void foo(const int longitud3)
/*
Cuando definimos `longitud` como `const int` en los parámetros de la función, sólo se le
está indicando al compilador que `longitud` no cambiará dentro de la función.
Sin embargo, su valor no se conoce hasta que la función es llamada, lo que ocurre al 
ejecutar el programa, no desde su compilación.
*/
{
  std::array<int, longitud3> elArray3{};
  /*
  `std::array` requiere que su tamaño sea una expresión constante en tiempo de compilación.
  Como `longitud` es un parámetro de función, su valor no puede ser determinado hasta que 
  `foo` sea llamada en tiempo de ejecución, por lo que no puede usarse como tamaño de
  `std::array`.
  */
}

int main()
{ 
  int longitud4{8}; // `longitud` es una expresión no-constante.
  std::array<int, longitud4> elArray4{}; // error: `longitud` es no-constante.

  foo(7); // Apenas hasta que el programa llega a esta línea es que se conoce el valor de
          // `longitud4`. 

  return 0;
}
```
