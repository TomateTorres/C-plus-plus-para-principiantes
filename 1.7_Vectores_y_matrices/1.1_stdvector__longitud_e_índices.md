Como vimos en el [texto anterior](1.0_Intro_a_stdvector.md), un `std::vector` tiene una cierta longitud dada por su cantidad de elementos. Hay varias maneras de obtener este valor, una de ellas es usando `.size()`:
```
#include <iostream>
#include <vector>

int main()
{
    std::vector primos { 2, 3, 5, 7, 11 };
    std::cout << "Tienes " << primos.size() << " números primos"
              << " en el vector." <<'\n'; 
    // OJO: `primos.size()` no es un entero (en el sentido de 
    //      que no es de tipo `int`). El uso de .size() retorna
    //      un dato de tipo `size_type`, que es un tipo de 
    //      entero sin signo (unsigned).        
    
    return 0;
}
```

En este contexto `size_type` es un alias para `std::size_t`, lo que significa que aunque estrictamente no son lo mismo, en el contexto de ciertas clases o bibliotecas, usar `size_type` es lo mismo que usar `std::size_t`. Por ejemplo, aquí en `std::vector`.

Lo que nos interesa sobre el hecho de que `primos.size()` sea de tipo `size_type` es que si intentamos utilizar `primos.size()` en un contexto donde el programa espera un entero con signo (algo de tipo `int` propiamente), podremos tener comportamientos inesperados, advertencias al compilar o directamente programas que no compilan.

Por ejemplo, si intentamos comparar `primos.size()` con un valor negativo o usarlo como argumento de una función que espera un `int` como parámetro, podríamos tener resultados no deseados o advertencias del compilador debido a la conversión implícita entre tipos con y sin signo.

Aquí se nos generaría un problema:
```
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vecA { 1, 2, 3, 4, 5 };
    std::vector<int> vecB { 1, 2, 3 };

    // Queremos calcular la diferencia en tamaños de nuestros
    // vectores.
    int diferencia {vecB.size() - vecA.size()}; 
    // vecA tiene 5 elementos, vecB tiene 3

    if (diferencia < 0){ // Si obtuvimos un número negativo.
        diferencia = -diferencia;
    }
    
    std::cout << "Diferencia de tamaños: " << diferencia << '\n';

    return 0;
}
```

Uno podría esperar que la diferencia sea $2$, porque $3 - 5 = 2$ y $-(-2) = 2$.

Pero en realidad pasa una de dos cosas:
* El código no compila si nuestra configuración del compilador es restrictiva (la advertencia mostrada en VSCode empieza: `narrowing conversion of...`)
* En caso de que el código sí compile, obtendremos un número grande como 4294967294 (dependiendo del sistema), ya que el sistema interpreta a los números sin signo de manera distinta a los enteros de tipo `int`, de modo que la resta de números sin signo no genera valores negativos y, en cambio, se comporta de manera inesperada.

Para arreglar este problema, deberemos convertir explícitamente a `vecA.size()` y `vecB.size()` en un tipo con signo (en este caso, `int`):

```
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vecA { 1, 2, 3, 4, 5 };
    std::vector<int> vecB { 1, 2, 3 };

    // Queremos calcular la diferencia en tamaños de nuestros
    // vectores.
    int diferencia {static_cast<int>(vecB.size())  
                    - static_cast<int>(vecA.size())}; 
    // vecA tiene 5 elementos, vecB tiene 3.

    if (diferencia < 0){ // Si obtuvimos un número negativo.
        diferencia = -diferencia;
    }
    
    std::cout << "Diferencia de tamaños: " << diferencia << '\n';

    return 0;
}
```

`static_cast <tipo_después_de_conversión>( valor )` es un operador que recibe un `valor` (o una expresión) de algún tipo (en nuestro ejemplo, `size_type`) y devuelve el mismo valor, pero ahora del `tipo_después_de_conversión` (en nuestro ejemplo, `int`). No todas las conversiones entre distintos tipos son posibles utilizando este operador.

De manera general, hacer conversiones mediante `static_cast` entre tipos de datos "parecidos" (por ejemplo, de `int` a `float` o de `float` a `int`, con la posible pérdida de lo que esté después del punto decimal) es posible en C++.

Aunque hay más opciones además de `.size()` para obtener el número de elementos en un `std::vector`, en C++, no hay una forma directa de obtener dicho valor como tipo `int`. Así que sin importar la herramienta que utilicemos, nos veremos obligados a usar `static_cast` o alguna herramienta similar si queremos el tamaño de nuestros vectores como tipo `int`.

![57615b8c0092a66c1d4058b1692955cc](https://github.com/user-attachments/assets/e6396d4c-8add-4892-b53d-a34425eca718)


## El problema de los índices sin signo
