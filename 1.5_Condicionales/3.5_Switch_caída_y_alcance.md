Al final del [texto anterior](3.0_Switch.md), mencionamos que cada secuencia de instrucciones después de una etiqueta `case` o `default` debía terminar con una declaración `break` o `return`. 

Pronto exploraremos por qué, además de algunas *sutilezas* sobre el alcance (*scope*) de las declaraciones `switch` que pueden llegar a causarnos problemas si no las tratamos con cuidado.

## Caída

Cuando una expresión condicional evaluada en `switch` coincide con una etiqueta `case` o cae en la etiqueta `default`, la ejecución empieza en la instrucción inmediata posterior a la etiqueta correspondiente. La ejecución continuará hasta que se satisfaga alguna de las siguientes condiciones de término:
1. Llegamos al final del bloque `switch` (o sea, el corchete de cierre).
2. Un `break` o `return` nos saca del bloque `switch` o de la función.
3. Algo más interrumpe a nuestro programa (ej.: Se nos congela la computadora, alguien divide entre cero y el universo explota, etc.)

Nótese que la existencia de otras etiquetas (sean `case`o `default`) **no** es una condición terminal. Entonces, sin un `break` o `return`, la ejecución del programa se desbordará en casos posteriores.

Veamos un ejemplo:
```
#include <iostream>

int main()
{
    switch (2)
    {
    case 1: // No coincide
        std::cout << 1 << '\n'; // Saltado
    case 2: // ¡Coincide!
        std::cout << 2 << '\n'; // Coincide, la ejecución empieza aquí
    case 3:
        std::cout << 3 << '\n'; // Esto también se ejecuta
    case 4:
        std::cout << 4 << '\n'; // Esto también se ejecuta
    default:
        std::cout << 5 << '\n'; // Esto también se ejecuta
    }

    return 0;
}
```
En el supuesto de que estemos usando [la configuración sugerida para VSCode](../Caja_de_herramientas/Configurar_el_compilador.md) (y claramente: VSCode), el programa anterior ni siquiera compilará y nos dará como error algo similar a `this statement may fall through [-Werror=implicit-fallthrough=]g`. 

En caso de que tengamos una configuración más permisiva, el output será:
```
2
3
4
5
```

Probablemente, esta no era nuestra intención. Cuando la ejecución fluye desde una declaración debajo de una etiqueta a declaraciones debajo de etiquetas subsecuentes, decimos que hubo **caída** o falla (*fallthrough*).

Como las *caídas* no suelen ser intencionales, muchos compiladores las señalarán como un fallo o advertencia.

### El atributo [[fallthrough]]

En caso de que intencionalmente escribamos código con *caídas*, es una práctica común escribir algún comentario que le indique a otros programadores (o a nosotros mismos 3 meses en el futuro que ya nisiquiera recordemos qué hacía el programa) que dicho comportamiento de nuestro programa es intencional. Lastimosamente, el compilador no sabe leer comentarios, así que de todos modos nos lo señalará como un error (y en configuraciones restrictivas, ni siquiera compilará nuestro código).

Para que el compilador nos deje de molestar, a partir de C++17 (la versión de C++ de 2017) tenemos al atributo `[[fallthrough]]`. 

Un **atributo** en C++ es una herramienta que le permite a los programadores darle información adicional al compilador sobre el código. Para especificar un atributo, el nombre del atributo es puesto dentro de corchetes dobles (`[[]]`).

Al atributo `[[fallthrough]]` lo ponemos en la posición donde debería ir el `break` o `return` seguido por `;` para indicarle al compilador que la caída es intencional:
```
#include <iostream>

int main()
{
    switch (2)
    {
    case 1: // No coincide
        std::cout << 1 << '\n'; // Saltado
        break; // Si no tenemos la intención de que haya caídas, 
               // debemos poner un `break` o `return`
    case 2: // ¡Coincide!
        std::cout << 2 << '\n'; // Coincide, la ejecución empieza aquí
        [[fallthrough]]; // Habrá caída y esta es intencional
    case 3:
        std::cout << 3 << '\n'; // Esto también se ejecuta
        [[fallthrough]];
    case 4:
        std::cout << 4 << '\n'; // Esto también se ejecuta
        [[fallthrough]];
    default:
        std::cout << 5 << '\n'; // Esto también se ejecuta
        break; // Aunque hemos llegado al último caso (que por
               // convención suele ser el `default`), debemos poner
               // un `break` (aquí poner un `return` no tiene sentido
               // pues no estamos dentro de una función)
    }

    return 0;
}
```
El programa imprime:
```
2
3
4
5
```

## Etiquetas de casos secuenciales

[Como ya hemos visto](Operadores_lógicos.md), podemos usar al operador lógico `||` (*o lógico*)  para combinar múltiples pruebas en una sola declaración.
```
bool esVocal(char c)
{
    return (c=='a' || c=='e' || c=='i' || c=='o' || c=='u' ||
            c=='A' || c=='E' || c=='I' || c=='O' || c=='U');
}
```
El código anterior sufre del mismo problema que las declaraciones `if`-`else`: `c` es evaluada múltiples veces y nosotros tenemos que asegurarnos de que efectivamente sea `c` la variable evaluada cada vez (un dedazo podría hacernos escribir `C=='a'` en vez de `c=='a'`). 

Podemos escribir un código que haga lo mismo usando una declaración `switch` poniendo varias etiquetas de casos de manera secuencial:
```
bool esVocal(char c)
{
    switch (c)
    {
    case 'a': // si `c` es 'a'
    case 'e': // o si `c` es 'e'
    case 'i': // o si `c` es 'i'
    case 'o': // o si `c` es 'o'
    case 'u': // o si `c` es 'u'
    case 'A': // o si `c` es 'A'
    case 'E': // o si `c` es 'E'
    case 'I': // o si `c` es 'I'
    case 'O': // o si `c` es 'O'
    case 'U': // o si `c` es 'U'
        return true;
    default:
        return false;
    }
}
```

Recordemos que **la ejecución empieza en la declaración inmediata posterior que corresponde a la etiqueta con la que el valor evaluado por `switch` coincidió**. Como las etiquetas **no** son declaraciones (son *etiquetas*), estas no cuentan.

La primer declaración después de tooodas las etiquetas `case` del programa anterior es `return true;`, así que si alguna de las etiquetas `case` coincide, la función `esVocal` nos devolverá `true`.

Entonces, podemos 'apilar' etiquetas `case` para que compartan el mismo conjunto de declaraciones una vez que una se cumpla. Esto no es considerado una *caída*, así que no es necesario usar el atributo `[[fallthrough]]`.

### Las etiquetas *no* definen un nuevo alcance
